-----------------------------------------------------------------------------
Informations generales :
-----------------------------------------------------------------------------

Groupe:
    - Vizzini Jeremy
    - Finiel Jeremie
    - Souchet Julie
    - Heckmann Victor


Configuration et execution :
    - source ~/.envarm/setenvarm.sh
    - ./configure
    - make 
    - ./simulator.sh -g -d
    - arm-eabi-gdb
    - file Examples/example1
    - target remote localhost:50000
    - load
    - stepi

Pour obtenir de l'aide il y a :
	- ./simulator.sh -h
    - ./arm_simulator -- help
	- ./arm_simulator --debug *.c

Bizzareries:
	- /home/f/fourneln/gnutools/arm/bin/arm-eabi-gdb

-----------------------------------------------------------------------------
Avancement du projet :
-----------------------------------------------------------------------------

Tâches :
    - gestion de la memoire         : implemente et teste
    - fetch d'une instruction       : implemente et pas teste
    - execution des instructions    : pas implemente et pas teste
    - gestion des interruptions IRQ : pas implemente et pas teste
    - compte rendu final            : en cours
    
Gestion des differentes instructions :
|--------------|---------|------------|-------|------------------------------|
| Instructions |   Doc   | Implemente | Teste | Nom du test                  |
|--------------|---------|------------|-------|------------------------------|
|     B        |   160   |    oui     |-------|        exampleB_BL.s         |
|     BL       |   160   |    oui     |-------|        exampleB_BL.s         |
|--------------|---------|------------|-------|------------------------------|
|     TEQ      | 378+442 |    oui     |-------|   exampleTST_TEQ_CMP_CMN.s   |
|     CMP      | 178+442 |    oui     |-------|   exampleTST_TEQ_CMP_CMN.s   |
|     CMN      | 176+442 |    oui     |-------|   exampleTST_TEQ_CMP_CMN.s   |
|     ORR      | 234+442 |    oui     |-------|     example_operations.s     |
|     MOV      | 218+442 |    oui     |-------|       exampleMOV_MVN.s       |
|     BIC      | 162+442 |    oui     |-------|     example_operations.s     |
|     MVN      | 232+442 |    oui     |-------|       exampleMOV_MVN.s       |
|     AND      | 115+442 |    oui     |-------|     example_operations.s     |
|     EOR      | 182+442 |    oui     |-------|     example_operations.s     |
|     SUB      | 358+442 |    oui     |-------|     example_operations.s     |
|     RSB      | 265+442 |    oui     |-------|     example_operations.s     |
|     ADD      | 156+442 |    oui     |-------|     example_operations.s     |
|     ADC      | 154+442 |    oui     |-------|     example_operations.s     |
|     SBC      | 275+442 |    oui     |-------|     example_operations.s     |
|     RSC      | 265+442 |    oui     |-------|     example_operations.s     |
|     TST      | 380+442 |    oui     |-------|   exampleTST_TEQ_CMP_CMN.s   |
|--------------|---------|------------|-------|------------------------------|
|     LDR      | 193+458 |    oui     |-------|         exampleLDR.s         |
|     LDRB     | 196+458 |    oui     |-------|         exampleLDRB.s        |
|     LDRH     | 204+473 |    oui     |-------|         exampleLDRH.s        |
|     STR      | 343+458 |    oui     |-------|         exampleSTR.s         |
|     STRB     | 345+458 |    oui     |-------|         exampleSTRB.s        |
|     STRH     | 354+473 |    oui     |-------|         exampleSTRH.s        |
|     LDM(1)   | 186+481 |    oui     |-------|       exampleLDM_STM.s       |
|     STM(1)   | 339+481 |    oui     |-------|       exampleLDM_STM.s       |
|--------------|---------|------------|-------|------------------------------|
|     MRS      |   224   |    oui     |-------|         exampleMSR.s         |
|     MSR      |   226   |    oui     |-------|         exampleMSR.s         |
|--------------|---------|------------|-------|------------------------------|

Ajouter en plus:
|--------------|---------|------------|-------|------------------------------|
|     LDRSB    | 206+473 |    oui     |-------|------------------------------|
|     LDRSH    | 208+473 |    oui     |-------|------------------------------|
|--------------|---------|------------|-------|------------------------------|
|     LDRT     | 210+458 |    oui     |-------|------------------------------|
|     STRT     | 356+458 |    oui     |-------|------------------------------|
|     LDRBT    | 198+458 |    oui     |-------|------------------------------|
|     STRBT    | 347+458 |    oui     |-------|------------------------------|
|     LDRD     | 196+473 |    oui     |-------|------------------------------|
|     STRD     | 349+473 |    oui     |-------|------------------------------|
|--------------|---------|------------|-------|------------------------------|
|     MSR      |   226   |    oui     |-------|------------------------------|
|--------------|---------|------------|-------|------------------------------|

Instructions ne respectant pas les classes:
    

TODO:
	- load et store ne declenche pas d'exeption
    

-----------------------------------------------------------------------------
Modification par fichiers :
-----------------------------------------------------------------------------

|---------------------|------------------------------------------------------|
| arm_core            | - ajout de fonctions pour l'access a NZCV            |
|---------------------|------------------------------------------------------|
| arm_exception       | - a completer ...                                    |
|---------------------|------------------------------------------------------|
| memory              | - implementation des access a la memoire             |
|---------------------|------------------------------------------------------|
| arm_instruction     | - ajout du fetch                                     |
|                     | - prise en compte des conditions                     |
|                     | - redirection des instructions dans les handlers     |
|---------------------|------------------------------------------------------|
| arm_data_processing | - a completer ...                                    |
|---------------------|------------------------------------------------------|
| arm_load_store      | - a completer ...                                    |
|---------------------|------------------------------------------------------|
| arm_branch_other    | - a completer ...                                    |
|---------------------|------------------------------------------------------|


Traitants des differentes classes d instructions (p110 figure A3-1)
|-----------------------------------------------|------|
| Traitants                                     | Code |
|-----------------------------------------------|------|
| arm_data_processing_shift                     | 000  |
| arm_data_processing_immediate                 | 001  |
| arm_load_store_immediate                      | 010  |
| arm_load_store                                | 011  |
| arm_load_store_multiple                       | 100  |
| arm_branch                                    | 101  |
| arm_coprocessor_load_store                    | 110  |
| arm_coprocessor_others_swi                    | 111  |
|-----------------------------------------------|------|

-----------------------------------------------------------------------------
Documentation :
-----------------------------------------------------------------------------

Schema d'une instruction vu au niveau de arm_instruction (p110 figure A3-1)
|-------------|----------|--------------------|
| 31 30 29 28 | 27 26 25 | 24 ############# 0 |
|-------------|----------|--------------------|
| cond field  | handler  | XXXXXXXXXXXXXXXXXX |
|-------------|----------|--------------------|

Les differentes valeurs du champ de condition (p112 figure A3-4)
|-----------------------------------|------|-----------|
| Description                       | Code | Flags     |
|-----------------------------------|------|-----------|
| Equal                             | 0000 | Z=1       |
| Not equal                         | 0001 | Z=0       |
| Carry set/unsigned higher or same | 0010 | C=1       |
| Carry clear/unsigned lower        | 0011 | C=0       |
| Minus/negative                    | 0100 | N=1       |
| Plus/positive or zero             | 0101 | N=0       |
| Overflow                          | 0110 | V=1       |
| No overflow                       | 0111 | V=0       |
| Unsigned higher                   | 1000 | C=1 Z=0   |
| Unsigned lower or same            | 1001 | C=0 Z=1   |
| Signed greater than or equal      | 1010 | N=V       |
| Signed less than                  | 1011 | N!=V      |
| Signed greater than               | 1100 | Z=0 N=V   |
| Signed less than or equal         | 1101 | Z=1 N!=V  |
| Always (unconditional)            | 1110 | Always    |
| 1111  (see page 110)              | 1111 | Undefined |
|-----------------------------------|------|-----------|

Operation de Data processing (p115 table A3-2)
|--------|----------|------------------------------|------------------------------------------------|
| Opcode | Mnemonic | Operation                    | Instructions action                            |
|--------|----------|------------------------------|------------------------------------------------|
|  0000  |   AND    | Logical AND                  | Rd := Rn AND shifter_operand                   |
|  0001  |   EOR    | Logical Exclusive OR         | Rd := Rn EOR shifter_operand                   |
|  0010  |   SUB    | Subtract                     | Rd := Rn - shifter_operand                     |
|  0011  |   RSB    | Reverse                      | Rd := shifter_operand - Rn                     |
|  0100  |   ADD    | Add                          | Rd := Rn + shifter_operand                     |
|  0101  |   ADC    | Add with Carry               | Rd := Rn + shifter_operand + Carry Flag        |
|  0110  |   SBC    | Subtract with Carry          | Rd := Rn - shifter_operand - NOT(Carry Flag)   |
|  0111  |   RSC    | Reverse Subtract with Carry  | Rd := shifter_operand - Rn - NOT(Carry Flag)   |
|  1000  |   TST    | Test                         | Update flags after Rn AND shifter_operand      |
|  1001  |   TEQ    | Test Equivalence             | Update flags after Rn EOR shifter_operand      |
|  1010  |   CMP    | Compare                      | Update flags after Rn - shifter_operand        |
|  1011  |   CMN    | Compare Negated              | Update flags after Rn + shifter_operand        |
|  1100  |   ORR    | Logical (inclusive) OR       | Rd := Rn OR shifter_operand                    |
|  1101  |   MOV    | Move                         | Rd := shifter_operand (no first operand)       |
|  1110  |   BIC    | Bit Clear                    | Rd := Rn AND NOT(shifter_operand)              |
|  1111  |   MVN    | Move Not                     | Rd := NOT shifter_operand (no first operand)   |
|--------|----------|------------------------------|------------------------------------------------|


Les différents Shifts (p.449-457)
|------|----------|---------------------------------------------------|
| Code | Mnemonic | Effet                                             |
|------|----------|---------------------------------------------------|
|  00  |   LSL    | Decale d'un certain nombre de bits vers la gauche |
|      |          | en ajoutant des 0 à droite                        |
|------|----------|---------------------------------------------------|
|  01  |   LSR    | Decale d'un certain nombre de bits vers la droite |
|      |          | en ajoutant des 0 à gauche                        |
|------|----------|---------------------------------------------------|
|  10  |   ASR    | Identique à LSR, sauf que les bits ajoutés à      |
|      |          | gauche sont les mêmes que le bit de poids fort    |
|------|----------|---------------------------------------------------|
|  11  |  ROR/RRX | Decale d'un certain nombre de bits vers la droite,|
|      |          | les bits dépassant à droite sont ajoutés à gauche |
|------|----------|---------------------------------------------------|
 
 
Load and store offset :
|--------------------------------------------|---|
| Types of offset                            | I |
|--------------------------------------------|---|
| Immediate offset on page A5-20.            | 0 |    
| Register offset on page A5-21.             | 1 | 
| Scaled register offset on page A5-22.      | 1 | 
| Immediate pre-indexed on page A5-24.       | 0 | 
| Register pre-indexed on page A5-25.        | 1 | 
| Scaled register pre-indexed on page A5-26  | 1 |
| Immediate post-indexed on page A5-28       | 0 | 
| Register post-indexed on page A5-30        | 1 | 
| Scaled register post-indexed on page A5-31 | 1 | 
|--------------------------------------------|---|




A GARDER AVANT VALIDATION:


DANS INSTRUCTION

// Immediate operand value
inline uint32_t get_immediate(arm_core p, uint32_t ins, uint8_t* shift_C) {
	uint32_t imm_8 = ins & 255;
	uint8_t rotate_imm = (ins >> 8) & 15;
	uint32_t result = ror(imm_8,(rotate_imm * 2));
	if(rotate_imm == 0) *shift_C = arm_read_c(p);
	else *shift_C = get_bit(result,31);
	return result;
}


// Shifted register operand value
inline uint32_t get_shifted(arm_core p, uint32_t ins, uint8_t* shift_C) {
    uint8_t shift_imm = (ins >> 7) & 31;
		uint8_t shift_code = (ins >> 5) & 3;
    uint32_t result = arm_read_register(p, ins & 15);
    if(!shift_imm && !shift_code) {
    	*shift_C = arm_read_c(p);
    }
    else {
    	uint8_t shift_value;
    	if(!get_bit(ins,4)) shift_value = shift_imm;
    	else {
				shift_value = arm_read_register(p, (ins >> 8) & 15);
		  }
		  result = shift(p, result, shift_code, shift_value, shift_C);
		}
		return result;
}


DANS BRANCH

int arm_mrs(arm_core p, uint32_t ins) {
	if (instruction_check_condition(p, ins))
	{
		uint8_t rd = get_bits(ins, 15, 12);
		uint8_t shift_C;
		uint32_t op = get_immediate(p, ins, &shift_C);

		//if (rd == 15)
		//UNPREDICTABLE

		//b19-b16 => SBO
		//b11-b0 => SBZ

		if (get_bit(ins, 22)) // R
			arm_write_register(p, rd, arm_read_spsr(p));
		else
			arm_write_register(p, rd, arm_read_cpsr(p));
	}

	return 0;
}

int arm_msr(arm_core p, uint32_t ins) {
	if (instruction_check_condition(p, ins))
	{
		uint32_t byte_mask, mask = 0;

		uint8_t shift_C;
		uint32_t op = get_immediate(p, ins, &shift_C);
		
		byte_mask = (get_bit(ins, 16) ? 0x000000FF : 0) | //C
							 (get_bit(ins, 17) ? 0x0000FF00 : 0) | //X
							 (get_bit(ins, 18) ? 0x00FF0000 : 0) | //S
							 (get_bit(ins, 19) ? 0xFF000000 : 0);  //F

		if (get_bit(ins, 22)) //R
		{
			if (arm_current_mode_has_spsr(p))
			{
				mask = byte_mask & (UserMask | PrivMask | StateMask);
				arm_write_spsr(p, (arm_read_spsr(p) & ~mask) | (op & mask));
			}
			//else
				//UNPREDICTABLE
		}
		else
		{
			if (arm_in_a_privileged_mode(p))
			{
				if ((op & StateMask) == 0)
					mask = byte_mask & (UserMask & PrivMask);
				//else
					//UNPREDICTABLE

			}
			else
				mask = byte_mask & UserMask;
			arm_write_spsr(p, (arm_read_spsr(p) & ~mask) | (op & mask));
		}
		
	}

	return 0;
}

DANS DATA PROCESSING

(value >> rotation) | (value << (32-rotation));

uint32_t get_immediate(arm_core p, uint32_t ins, uint8_t *shift_C) {
	uint32_t imm_8 = ins & 255;
	uint8_t rotate_imm = (ins >> 8) & 15;
	uint32_t result = ror(imm_8,(rotate_imm * 2));

	if (shift_C) {
		if(rotate_imm == 0)
			*shift_C = arm_read_c(p);
		else 
			*shift_C = get_bit(result,31);
	}
	return result;
}

